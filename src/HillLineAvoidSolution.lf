/**
 * Display the outputs from the line sensors on the
 * <a href="https://www.pololu.com/docs/0J86">Pololu 3pi+ 2040 robot</a>.
 * This program spends the first 10 seconds in calibration mode, during which
 * you should move the robot over the light and dark areas that you would like
 * it to detect.  It then switches into measurement mode and displays the
 * measured reflectance of the five IR sensors.
 *
 * @author Abhi Gundrala
 * @author Edward A. Lee
 */
 target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
  }
  
  import Line from "lib/Line.lf"
  import Display from "lib/Display.lf"
  import GyroAngle from "lib/IMU.lf"
  import Motors from "lib/Motors.lf"

  reactor Reflect_to_LineDetectType{
    input reflect:uint16_t[5];
    output line_detect_type:int;
    reaction(startup)->line_detect_type{=
      lf_set(line_detect_type,0);
    =}
    reaction(reflect)->line_detect_type{=
      if(reflect->value[0]!=0){
        lf_set(line_detect_type,1);
      }
      else if(reflect->value[2]!=0){
        lf_set(line_detect_type,2);
      }
      else if(reflect->value[4]!=0){
        lf_set(line_detect_type,3);
      }
      else{
        lf_set(line_detect_type,0);
      }
    =}
  }

  reactor RobotLineBack {
    input gyro_angle:float;
    input line_detect_type:int;
    output motor_left_power:float;
    output motor_right_power:float;

    state turned_angle: float = 0.0;
    state pre_turned_angle: float = 0.0;
    initial mode DRIVE_FORWARD {
        reaction(startup) -> motor_left_power, motor_right_power {=
            lf_set(motor_left_power,0.1f);
            lf_set(motor_right_power,0.1f);
        =}
        reaction(line_detect_type) -> motor_left_power, motor_right_power, TURN_90, TURN_AROUND, TURN_270 {=
          if(line_detect_type->value==1){
              lf_set_mode(TURN_90);
          }
          if(line_detect_type->value==2){
              lf_set_mode(TURN_AROUND);
          }
          if(line_detect_type->value==3){
              lf_set_mode(TURN_270);
          }
        =}
    }
    mode TURN_AROUND {
        reaction(gyro_angle) ->  motor_left_power, motor_right_power, DRIVE_FORWARD {=
            lf_set(motor_left_power,-0.1f);
            lf_set(motor_right_power,0.1f);// Assuming turning left requires opposite motor powers

            self->turned_angle = gyro_angle->value;
            if (((self->turned_angle)-(self->pre_turned_angle)) >= 180.0f) { // 90 degrees
                self->pre_turned_angle = self->turned_angle; // Reset distance for the next drive phase
                lf_set(motor_left_power,0.1f);
                lf_set(motor_right_power,0.1f);
                lf_set_mode(DRIVE_FORWARD);
            }
        =}
    }
    mode TURN_90 {
      reaction(gyro_angle) ->  motor_left_power, motor_right_power, DRIVE_FORWARD {=
          lf_set(motor_left_power,-0.1f);
          lf_set(motor_right_power,0.1f);// Assuming turning left requires opposite motor powers

          self->turned_angle = gyro_angle->value;
          if (((self->turned_angle)-(self->pre_turned_angle)) >= 90.0f) { // 90 degrees
              self->pre_turned_angle = self->turned_angle; // Reset distance for the next drive phase
              lf_set(motor_left_power,0.1f);
              lf_set(motor_right_power,0.1f);
              lf_set_mode(DRIVE_FORWARD);
          }
      =}
  }
  mode TURN_270 {
    reaction(gyro_angle) ->  motor_left_power, motor_right_power, DRIVE_FORWARD {=
        lf_set(motor_left_power,0.1f);
        lf_set(motor_right_power,-0.1f);// Assuming turning left requires opposite motor powers

        self->turned_angle = gyro_angle->value;
        if (((self->turned_angle)-(self->pre_turned_angle)) <= -90.0f) { // 90 degrees
            self->pre_turned_angle = self->turned_angle; // Reset distance for the next drive phase
            lf_set(motor_left_power,0.1f);
            lf_set(motor_right_power,0.1f);
            lf_set_mode(DRIVE_FORWARD);
        }
    =}
}
  }

  main reactor(calibration_time: time = 10 s, sample_period: time = 100 ms) {
    line = new Line()
    disp = new Display()
    gyroAngle = new GyroAngle()
    motors = new Motors()
    robotlineback=new RobotLineBack()
    reflect_linedetecttype=new Reflect_to_LineDetectType()
    timer t(0, sample_period)
    // Timer used to display seconds.
    timer seconds(0, 1 s)
    timer end_calibration(calibration_time)
    state count: int = 0
  
    gyroAngle.z -> robotlineback.gyro_angle;
    line.reflect -> reflect_linedetecttype.reflect;
    reflect_linedetecttype.line_detect_type-> robotlineback.line_detect_type;
    robotlineback.motor_left_power -> motors.left_power;
    robotlineback.motor_right_power -> motors.right_power;

    reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
      lf_set(disp.line0, "CALIBRATING");
      lf_set(disp.line1, "Roll robot over");
      lf_set(disp.line2, "light and dark.");
    =}
    
    reaction(t)->gyroAngle.trigger{=
        lf_set(gyroAngle.trigger,true);
    =}

    reaction(seconds) -> disp.line3 {=
      static char buf[17];
      snprintf(buf, 17, "time:%8d s", self->count++);
      lf_set(disp.line3, buf);
    =}
  
    reaction(end_calibration) -> line.calibrate {=
      lf_set(line.calibrate, false);
    =}
  
    reaction(t) -> line.trigger {=
      lf_set(line.trigger, true);
    =}
  
    reaction(line.reflect) -> disp.line0, disp.line1, disp.line2 {=
      static char buf0[17];
      static char buf1[17];
      static char buf2[17];
      snprintf(buf0, 17, "0:%4d 1:%4d", line.reflect->value[0], line.reflect->value[1]);
      snprintf(buf1, 17, "2:%4d 3:%4d", line.reflect->value[2], line.reflect->value[3]);
      snprintf(buf2, 17, "4:%4d", line.reflect->value[4]);
      lf_set(disp.line0, buf0);
      lf_set(disp.line1, buf1);
      lf_set(disp.line2, buf2);
    =}
  }
  