
target C {
    platform: {
      name: "rp2040",
      board: "pololu_3pi_2040_robot"
    },
    threading: false,
}

import Motors from "lib/Motors.lf";
import Display from "lib/Display.lf";
import GyroAngle from "lib/IMU.lf";
import Encoders from "lib/Encoders.lf"
preamble{=
    #define WHEEL_DIAMETER 0.03175  //in meters
=}
reactor RobotSquare {
    input encoder_distance:float;
    input gyro_angle:float;
    output motor_left_power:float;
    output motor_right_power:float;
    // output robotsquare_travelled_distance:float;
    // output robotsquare_turned_angle:float;

    state travelled_distance:float = 0.0;
    state pre_travelled_distance:float = 0.0;
    state turned_angle: float = 0.0;
    state pre_turned_angle: float = 0.0;



    initial mode DRIVE_FORWARD {
        reaction(startup) -> motor_left_power, motor_right_power {=
            lf_set(motor_left_power,0.1f);
            lf_set(motor_right_power,0.1f);
        =}
        // reaction(encoder_distance){=
        //     
        // =}
        reaction(encoder_distance) -> motor_left_power, motor_right_power, TURN_90_DEGREES {=
            lf_set(motor_left_power,0.1f);
            lf_set(motor_right_power,0.1f);// Assuming turning left requires opposite motor powers
            self->travelled_distance=encoder_distance->value;
            //self->travelled_distance += 0.1f; // Assuming a constant speed and a fixed reaction interval
            if (((self->travelled_distance)-(self->pre_travelled_distance)) >= 0.5f) { // Half a meter
                lf_set_mode(TURN_90_DEGREES);
            }
        =}
    }

    mode TURN_90_DEGREES {
        reaction(gyro_angle) ->  motor_left_power, motor_right_power, DRIVE_FORWARD {=
            lf_set(motor_left_power,-0.1f);
            lf_set(motor_right_power,0.1f);// Assuming turning left requires opposite motor powers

            self->turned_angle = gyro_angle->value;
            if (((self->turned_angle)-(self->pre_turned_angle)) >= 90.0f) { // 90 degrees
                lf_set_mode(DRIVE_FORWARD);
                self->pre_turned_angle = self->turned_angle; // Reset distance for the next drive phase
                self->pre_travelled_distance = self->travelled_distance; // Reset angle for the next turn phase
            }
        =}
    }
}

reactor AngleToDistance{
    input left_angle:int32_t;
    input right_angle:int32_t;
    output left_distance:float;
    output right_distance:float;
    preamble{=    
    float angle2Distance(int32_t angle){
        return (float)angle/360.0*3.14*WHEEL_DIAMETER;
    }
    =}
    reaction(left_angle)->left_distance {=
        lf_set(left_distance,angle2Distance(left_angle->value));
    =}
    reaction(right_angle)->right_distance {=
        lf_set(right_distance,angle2Distance(right_angle->value));
    =}
  }

main reactor {
    timer t(0, 100 msec); // Assuming a 100 msec interval for simplicity
    robotSquare = new RobotSquare();
    motors = new Motors();
    display = new Display();
    gyroAngle = new GyroAngle();
    encoder = new Encoders()
    angletodistance = new AngleToDistance()

    reaction(t)->gyroAngle.trigger{=
        lf_set(gyroAngle.trigger,true);
    =}

    // Trigger the GyroAngle reactor at regular intervals
    robotSquare.motor_left_power -> motors.left_power;
    robotSquare.motor_right_power -> motors.right_power;
    gyroAngle.z -> robotSquare.gyro_angle;
    reaction(gyroAngle.z)->display.line0 {=
        static char buf[17];
        snprintf(buf, 17, "z: %.1f", gyroAngle.z->value);
        lf_set(display.line0, buf);
    =}

    reaction(t) -> encoder.trigger {=
        lf_set(encoder.trigger, true);
    =}
    encoder.left->angletodistance.left_angle
    encoder.right->angletodistance.right_angle

    angletodistance.left_distance->robotSquare.encoder_distance;
}
